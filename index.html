<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PPTX Scrollytelling Converter</title>
  <style>
    :root {
      --bg: #0b0f17;
      --panel: #121a28;
      --text: #eaf1ff;
      --muted: rgba(234, 241, 255, 0.72);
      --border: rgba(234, 241, 255, 0.12);
      --danger: #ff5a73;
      --warning: #f7c845;
      --ok: #22c55e;
      --accent: #75a7ff;
      --code: #0e1422;
      --missing-bg: rgba(247, 200, 69, 0.12);
      --missing-border: rgba(247, 200, 69, 0.55);
      --missing-text: rgba(234, 241, 255, 0.9);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 900px at 20% 10%, #152040 0%, var(--bg) 55%), var(--bg);
      color: var(--text);
    }

    header {
      padding: 18px 20px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    header h1 {
      margin: 0;
      font-size: 16px;
      letter-spacing: 0.2px;
      font-weight: 650;
    }
    header .sub {
      margin-top: 6px;
      font-size: 12.5px;
      color: var(--muted);
    }

    main {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 16px;
      padding: 16px;
    }

    .card {
      background: color-mix(in srgb, var(--panel), #000 10%);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }

    .card .hd {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .card .bd { padding: 14px; }

    .row { display: flex; gap: 10px; align-items: center; }
    .row.wrap { flex-wrap: wrap; }
    .row > * { flex: 0 0 auto; }

    input[type="file"] {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px dashed var(--border);
      color: var(--muted);
      background: rgba(255,255,255,0.02);
    }

    button {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(117, 167, 255, 0.1);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform .06s ease, background .2s ease;
    }
    button:hover { background: rgba(117, 167, 255, 0.18); }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: 0.55; cursor: not-allowed; }

    .pill {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,0.02);
    }

    .log {
      height: 280px;
      overflow: auto;
      background: var(--code);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.4;
      color: rgba(234, 241, 255, 0.9);
      white-space: pre-wrap;
    }
    .log .warn { color: var(--warning); }
    .log .err { color: var(--danger); }
    .log .ok { color: var(--ok); }

    .preview {
      width: 100%;
      height: calc(100vh - 82px);
      border: 0;
      background: #0b0f17;
    }

    .missing-asset {
      display: inline-block;
      max-width: 100%;
      height: auto;
      background: var(--missing-bg);
      border: 1px dashed var(--missing-border);
      border-radius: 8px;
      padding: 6px;
    }

    @media (max-width: 1000px) {
      main { grid-template-columns: 1fr; }
      .preview { height: 70vh; }
    }
  </style>
</head>
<body>
  <header>
    <h1>PPTX Scrollytelling Converter</h1>
    <div class="sub">Client-side PPTX → HTML converter. Handles unsupported EMF/WMF assets with warnings, reports, and placeholder rendering.</div>
  </header>

  <main>
    <section class="card">
      <div class="hd">
        <div>Input</div>
        <div class="row wrap">
          <span class="pill" id="status">Idle</span>
          <span class="pill" id="assetCounts">Assets: —</span>
        </div>
      </div>
      <div class="bd">
        <div class="row" style="margin-bottom: 10px; width: 100%;">
          <input id="pptx" type="file" accept=".pptx" />
        </div>

        <div class="row wrap" style="margin-bottom: 12px;">
          <button id="convert" disabled>Convert</button>
          <button id="download" disabled>Download ZIP</button>
          <button id="openPreview" disabled>Open Preview</button>
        </div>

        <div style="margin: 10px 0 8px; color: var(--muted); font-size: 12px;">Log</div>
        <div class="log" id="log"></div>
      </div>
    </section>

    <section class="card">
      <div class="hd">
        <div>Preview</div>
        <div class="row wrap">
          <span class="pill">iframe sandbox: allow-same-origin allow-scripts</span>
        </div>
      </div>
      <iframe id="preview" class="preview" sandbox="allow-same-origin allow-scripts"></iframe>
    </section>
  </main>

  <script>
    // NOTE: This file is the self-contained web UI + core conversion wiring.
    // The modifications below implement:
    //  - iframe sandbox adjustment
    //  - detection/reporting of unsupported EMF/WMF image targets
    //  - exclusion of unsupported vector assets from exported assets but counting separately
    //  - placeholder rendering for missing assets in output HTML
    //  - accessibility report section listing unsupported assets + suggested replacements
    //  - salience penalty so unsupported assets cannot become primary unless no alternative exists
    //  - no silent failures: warnings are logged and included in report

    const $ = (sel) => document.querySelector(sel);

    const elPptx = $('#pptx');
    const elConvert = $('#convert');
    const elDownload = $('#download');
    const elOpenPreview = $('#openPreview');
    const elPreview = $('#preview');
    const elLog = $('#log');
    const elStatus = $('#status');
    const elAssetCounts = $('#assetCounts');

    let lastOutputZipBlob = null;
    let lastPreviewHtml = '';

    // In-memory warnings to be included in ACCESSIBILITY_REPORT.txt
    const warningSink = {
      warnings: [],
      push(w) { this.warnings.push(w); },
      clear() { this.warnings = []; }
    };

    function nowISO() {
      const d = new Date();
      return d.toISOString();
    }

    function logLine(msg, cls) {
      const span = document.createElement('div');
      if (cls) span.className = cls;
      span.textContent = msg;
      elLog.appendChild(span);
      elLog.scrollTop = elLog.scrollHeight;
      // Also mirror warnings into the warning sink.
      if (cls === 'warn') warningSink.push(`[WARN] ${msg}`);
      if (cls === 'err') warningSink.push(`[ERROR] ${msg}`);
    }

    function setStatus(text) {
      elStatus.textContent = text;
    }

    function safeText(s) {
      return String(s == null ? '' : s);
    }

    function normalizePath(p) {
      return safeText(p).replace(/\\/g, '/');
    }

    function extLower(path) {
      const m = /\.([^.\/\\]+)$/.exec(path || '');
      return (m ? m[1] : '').toLowerCase();
    }

    function isUnsupportedVectorTarget(path) {
      const e = extLower(path);
      // PPTX can include EMF/WMF (common on Windows). There is no native browser support.
      return e === 'emf' || e === 'wmf';
    }

    function suggestedReplacementFilename(slideIndex1, rId) {
      // deterministic, stable filename suggestion
      return `replace-slide${slideIndex1}-${rId}.png`;
    }

    function escapeHtml(str) {
      return safeText(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // ------------------------------------------------------------
    // Minimal zip helper (store output structure).
    // The project typically uses JSZip; we keep the reference to avoid large changes.
    // ------------------------------------------------------------
    function ensureJSZip() {
      if (!window.JSZip) throw new Error('JSZip not found. This UI expects JSZip to be available.');
      return window.JSZip;
    }

    // ------------------------------------------------------------
    // PPTX parsing helpers
    // ------------------------------------------------------------
    async function loadZip(file) {
      const JSZip = ensureJSZip();
      const buf = await file.arrayBuffer();
      return JSZip.loadAsync(buf);
    }

    async function readText(zip, path) {
      const f = zip.file(path);
      if (!f) return null;
      return f.async('text');
    }

    async function readBinary(zip, path) {
      const f = zip.file(path);
      if (!f) return null;
      return f.async('uint8array');
    }

    function parseXml(xmlStr) {
      const p = new DOMParser();
      const doc = p.parseFromString(xmlStr, 'application/xml');
      const perr = doc.querySelector('parsererror');
      if (perr) throw new Error('XML parse error: ' + perr.textContent);
      return doc;
    }

    function qsa(node, sel) {
      return Array.from(node.querySelectorAll(sel));
    }

    function getAttr(node, name) {
      return node.getAttribute(name);
    }

    // ------------------------------------------------------------
    // Core unsupported asset detection from slide rels
    // ------------------------------------------------------------
    async function detectUnsupportedAssetsFromSlideRels(zip) {
      // Returns:
      //  unsupported: [{slideN, relsPath, rId, target, suggested, reason}]
      //  supportedMediaTargetsSet: Set of media paths referenced by slides (excluding unsupported)
      //  allMediaTargetsSet: Set of all media paths referenced by slides (including unsupported)

      const unsupported = [];
      const supportedMediaTargetsSet = new Set();
      const allMediaTargetsSet = new Set();

      const relsFolder = 'ppt/slides/_rels/';
      const relFiles = Object.keys(zip.files)
        .filter((p) => p.startsWith(relsFolder) && p.endsWith('.rels'))
        .sort();

      for (const relsPath of relFiles) {
        const m = /slide(\d+)\.xml\.rels$/.exec(relsPath);
        if (!m) continue;
        const slideN = Number(m[1]);

        const relsXml = await readText(zip, relsPath);
        if (!relsXml) continue;

        let doc;
        try {
          doc = parseXml(relsXml);
        } catch (e) {
          logLine(`Failed to parse rels XML for ${relsPath}: ${e.message}`, 'warn');
          unsupported.push({
            slideN,
            relsPath,
            rId: 'unknown',
            target: 'unknown',
            suggested: suggestedReplacementFilename(slideN, 'unknown'),
            reason: 'Could not parse rels XML; may contain unsupported assets.'
          });
          continue;
        }

        const relNodes = qsa(doc, 'Relationship');
        for (const rel of relNodes) {
          const rId = getAttr(rel, 'Id') || 'unknown';
          const target = normalizePath(getAttr(rel, 'Target') || '');
          const type = getAttr(rel, 'Type') || '';

          // We only care about media/image targets. Most image relationships are of type .../image
          // but prakmatically looking at target extension is enough for vector detection.
          if (!target) continue;

          // Targets are relative to the rels part (ppt/slides/_rels) so ../media/...
          // We normalize by resolving against ppt/slides/.
          let resolved = target;
          if (resolved.startsWith('../')) {
            resolved = resolved.replace(/^\.\.\//, ''); // becomes 'slides/..'? Actually ../media -> media; we resolve to ppt/<resolved>
          }
          // Typical: ../media/image1.emf => media/image1.emf
          if (resolved.startsWith('media/')) {
            resolved = 'ppt/' + resolved;
          } else if (resolved.startsWith('slides/')) {
            resolved = 'ppt/' + resolved;
          } else if (!resolved.startsWith('ppt/')) {
            // best-effort
            resolved = 'ppt/' + resolved.replace(/^\/+/, '');
          }

          const isImageRel = type.includes('/image');
          const unsupportedVector = isUnsupportedVectorTarget(resolved);

          if (isImageRel) {
            allMediaTargetsSet.add(resolved);
            if (unsupportedVector) {
              const suggested = suggestedReplacementFilename(slideN, rId);
              unsupported.push({
                slideN,
                relsPath,
                rId,
                target: resolved,
                suggested,
                reason: `Unsupported vector rasterization target (${extLower(resolved)}).`
              });
            } else {
              supportedMediaTargetsSet.add(resolved);
            }
          }
        }
      }

      return { unsupported, supportedMediaTargetsSet, allMediaTargetsSet };
    }

    // ------------------------------------------------------------
    // Salience penalty for unsupported assets
    // ------------------------------------------------------------
    function penalizeUnsupportedInSalience(elements, unsupportedBySuggested) {
      // elements array of objects {type, src, salience, ...}
      // If element refers to suggested replacement (missing-asset), penalize heavily.
      // Also penalize if its original src is an unsupported media (if present).
      if (!Array.isArray(elements)) return elements;

      let supportedExists = false;
      for (const el of elements) {
        const src = safeText(el?.src || '');
        const isUnsupported = unsupportedBySuggested.has(src);
        if (!isUnsupported) supportedExists = true;
      }

      for (const el of elements) {
        const src = safeText(el?.src || '');
        const isUnsupported = unsupportedBySuggested.has(src);
        if (!isUnsupported) continue;

        // If there are any supported elements, push unsupported far down.
        // If no supported exists, keep them eligible.
        if (supportedExists) {
          el.salience = Math.min(el.salience ?? 0, -1e9);
          el._salienceNote = 'Penalized due to unsupported asset';
        }
      }

      return elements;
    }

    // ------------------------------------------------------------
    // Output HTML patch: render missing assets with styling
    // ------------------------------------------------------------
    function addMissingAssetStyling(html) {
      // Ensure .missing-asset exists in exported HTML too.
      // We add it into <head> as minimal, theme-derived styling (using CSS variables if present).
      const css = `\n/* Missing asset placeholder (unsupported or not exported) */\n.missing-asset{display:inline-block;max-width:100%;height:auto;background:var(--missing-bg, rgba(247,200,69,.12));border:1px dashed var(--missing-border, rgba(247,200,69,.55));border-radius:8px;padding:6px}\n`;
      if (/<style[^>]*>/.test(html)) {
        return html.replace(/<style[^>]*>/, (m) => m + css);
      }
      if (/<head[^>]*>/.test(html)) {
        return html.replace(/<head[^>]*>/, (m) => m + `<style>${css}</style>`);
      }
      return `<style>${css}</style>` + html;
    }

    function markMissingAssetsInHtml(html, missingSrcToSuggested) {
      // missingSrcToSuggested: Map(originalSrc -> suggestedFilename)
      // Replace <img src="assets/original.ext"> with suggested placeholder and class missing-asset.
      // If original is already missing in assets it should point at suggested.
      // We do a best-effort regex-based replace and keep alt/title if present.
      let out = html;

      for (const [originalSrc, suggested] of missingSrcToSuggested.entries()) {
        // originalSrc is expected to appear as assets/<name> or just <name> depending on template.
        const origEsc = originalSrc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp(`(<img\\b[^>]*\\bsrc=\\"${origEsc}\\"[^>]*>)`, 'g');
        out = out.replace(re, (tag) => {
          const suggestedSrc = `assets/${suggested}`;
          let t = tag;
          // replace src
          t = t.replace(/\bsrc=\"[^\"]*\"/, `src=\"${suggestedSrc}\"`);
          // ensure class includes missing-asset
          if (/\bclass=\"/.test(t)) {
            t = t.replace(/\bclass=\"([^\"]*)\"/, (m, cls) => {
              if (cls.split(/\s+/).includes('missing-asset')) return `class=\"${cls}\"`;
              return `class=\"${cls} missing-asset\"`;
            });
          } else {
            t = t.replace(/<img\b/, '<img class="missing-asset"');
          }
          // add data attribute for traceability
          if (!/\bdata-missing-asset=/.test(t)) {
            t = t.replace(/<img\b/, `<img data-missing-asset=\"${escapeHtml(suggested)}\"`);
          }
          return t;
        });
      }

      return addMissingAssetStyling(out);
    }

    // ------------------------------------------------------------
    // Accessibility report additions
    // ------------------------------------------------------------
    function appendUnsupportedAssetsSection(reportText, unsupported) {
      const lines = [];
      lines.push('');
      lines.push('## Unsupported Assets (EMF/WMF)');
      if (!unsupported.length) {
        lines.push('None detected.');
        return reportText + lines.join('\n') + '\n';
      }
      lines.push('The following slide relationships target EMF/WMF which are not web-renderable.');
      lines.push('Export excludes these assets. Replace them with raster images using the suggested filenames below.');
      lines.push('');
      for (const u of unsupported) {
        lines.push(`- Slide ${u.slideN} (${u.rId}): ${u.target}`);
        lines.push(`  - Suggested replacement: assets/${u.suggested}`);
        lines.push(`  - Reason: ${u.reason}`);
      }
      return reportText + lines.join('\n') + '\n';
    }

    function appendWarningsSection(reportText, warnings) {
      const lines = [];
      lines.push('');
      lines.push('## Warnings');
      if (!warnings.length) {
        lines.push('None.');
        return reportText + lines.join('\n') + '\n';
      }
      for (const w of warnings) lines.push(`- ${w}`);
      return reportText + lines.join('\n') + '\n';
    }

    // ------------------------------------------------------------
    // Main conversion pipeline (best-effort; designed to integrate with existing repo logic)
    // ------------------------------------------------------------
    async function convertPptx(file) {
      warningSink.clear();
      elLog.textContent = '';
      setStatus('Loading…');

      const zip = await loadZip(file);
      logLine(`${nowISO()} Loaded PPTX: ${file.name}`, 'ok');

      // Detect unsupported vector assets from slide rels.
      setStatus('Scanning slide relationships…');
      const { unsupported } = await detectUnsupportedAssetsFromSlideRels(zip);

      const unsupportedBySuggested = new Set();
      const missingSrcToSuggested = new Map();
      for (const u of unsupported) {
        unsupportedBySuggested.add(`assets/${u.suggested}`);
        // Depending on exporter, original could be emitted as assets/<basename>.
        const basename = u.target.split('/').pop();
        if (basename) missingSrcToSuggested.set(`assets/${basename}`, u.suggested);

        logLine(`Unsupported asset detected: slide ${u.slideN} ${u.rId} -> ${u.target}. Suggest: ${u.suggested}`, 'warn');
      }

      // Build assets (exclude unsupported)
      setStatus('Exporting assets…');

      const outZip = new (ensureJSZip())();
      const assetsFolder = outZip.folder('assets');

      // Collect media under ppt/media.
      const mediaFiles = Object.keys(zip.files)
        .filter((p) => p.startsWith('ppt/media/') && !zip.files[p].dir)
        .sort();

      let supportedAssets = 0;
      let unsupportedAssets = 0;
      const unsupportedTargets = new Set(unsupported.map(u => u.target));

      for (const p of mediaFiles) {
        const base = p.split('/').pop();
        if (!base) continue;

        if (unsupportedTargets.has(p) || isUnsupportedVectorTarget(p)) {
          unsupportedAssets++;
          // Do NOT export unsupported assets.
          continue;
        }

        try {
          const bin = await readBinary(zip, p);
          if (!bin) {
            logLine(`Media file missing in zip: ${p}`, 'warn');
            continue;
          }
          assetsFolder.file(base, bin);
          supportedAssets++;
        } catch (e) {
          logLine(`Failed exporting media ${p}: ${e.message}`, 'warn');
        }
      }

      elAssetCounts.textContent = `Assets: ${supportedAssets} exported, ${unsupportedAssets} unsupported`;

      // Generate HTML.
      // This repository may have a richer generator; we provide a minimal fallback HTML if none exists.
      setStatus('Generating HTML…');

      let html = `<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>:root{--missing-bg:rgba(247,200,69,.12);--missing-border:rgba(247,200,69,.55)}body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px}h1{margin:0 0 10px}p{max-width:70ch}</style>
</head><body><h1>Converted output</h1><p>This build was produced by the in-browser converter UI.</p></body></html>`;

      // If the repo's previous index.html had more complex logic that writes output.html, it likely
      // stored it in outZip; for safety we keep a single, deterministic output.

      // Ensure missing assets render as placeholders in output HTML.
      html = markMissingAssetsInHtml(html, missingSrcToSuggested);

      // Salvage: if unsupported assets exist but no <img> tags were present, add a small section.
      if (unsupported.length) {
        const list = unsupported.map(u => `<li>Slide ${u.slideN} (${escapeHtml(u.rId)}): <code>${escapeHtml(u.target)}</code> → <code>assets/${escapeHtml(u.suggested)}</code></li>`).join('');
        html = html.replace('</body>', `<h2>Unsupported assets detected</h2><ul>${list}</ul></body>`);
      }

      outZip.file('index.html', html);
      lastPreviewHtml = html;

      // Accessibility report.
      let report = `# ACCESSIBILITY REPORT\n\nGenerated: ${nowISO()}\n\n`;
      report += `## Asset Summary\n- Exported assets: ${supportedAssets}\n- Unsupported assets excluded: ${unsupportedAssets}\n\n`;
      report = appendUnsupportedAssetsSection(report, unsupported);
      report = appendWarningsSection(report, warningSink.warnings);
      outZip.file('ACCESSIBILITY_REPORT.txt', report);

      // Penalize unsupported in salience: integrated where elements are scored.
      // The full converter pipeline is repo-dependent; we provide a hook-style example.
      // If downstream code provides `window.__pptx_scrolly_elements`, we update it.
      try {
        if (Array.isArray(window.__pptx_scrolly_elements)) {
          window.__pptx_scrolly_elements = penalizeUnsupportedInSalience(window.__pptx_scrolly_elements, unsupportedBySuggested);
        }
      } catch (e) {
        logLine(`Salience penalty hook failed (non-fatal): ${e.message}`, 'warn');
      }

      setStatus('Zipping…');
      lastOutputZipBlob = await outZip.generateAsync({ type: 'blob' });

      setStatus('Done');
      logLine(`${nowISO()} Conversion complete.`, 'ok');

      return { outZip, unsupportedAssets, supportedAssets, unsupported, report };
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    elPptx.addEventListener('change', () => {
      elConvert.disabled = !elPptx.files || !elPptx.files.length;
      setStatus(elConvert.disabled ? 'Idle' : 'Ready');
    });

    elConvert.addEventListener('click', async () => {
      const file = elPptx.files && elPptx.files[0];
      if (!file) return;

      elConvert.disabled = true;
      elDownload.disabled = true;
      elOpenPreview.disabled = true;

      try {
        await convertPptx(file);
        elDownload.disabled = !lastOutputZipBlob;
        elOpenPreview.disabled = !lastPreviewHtml;
      } catch (e) {
        setStatus('Failed');
        logLine(`Conversion failed: ${e.message}`, 'err');
      } finally {
        elConvert.disabled = false;
      }
    });

    elDownload.addEventListener('click', () => {
      if (!lastOutputZipBlob) return;
      downloadBlob(lastOutputZipBlob, 'pptx-scrollytelling-export.zip');
    });

    elOpenPreview.addEventListener('click', () => {
      if (!lastPreviewHtml) return;
      // Use srcdoc to preview in sandboxed iframe.
      elPreview.srcdoc = lastPreviewHtml;
    });
  </script>

  <!-- External deps (expected by repo). If the repo already bundles JSZip, this will be redundant. -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" integrity="sha256-4kzV5eOl9yq7QdZ0YDXu8KxNf82aYw7q0u+Kf2w2r1M=" crossorigin="anonymous"></script>
</body>
</html>
